

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DistributedBag &mdash; chpldoc 0.0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="chpldoc 0.0.1 documentation" href="../../index.html"/>
        <link rel="next" title="DistributedDeque" href="DistributedDeque.html"/>
        <link rel="prev" title="Collection" href="Collection.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> chpldoc
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">chpldoc documentation</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Collection.html">Collection</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">DistributedBag</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#summary">Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="#usage">Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#planned-improvements">Planned Improvements</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="DistributedDeque.html">DistributedDeque</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">chpldoc</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
    <li>DistributedBag</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/modules/collections/DistributedBag.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="module-DistributedBag"></span><div class="section" id="distributedbag">
<h1>DistributedBag<a class="headerlink" href="#distributedbag" title="Permalink to this headline">¶</a></h1>
<p><strong>Usage</strong></p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">DistributedBag</span><span class="p">;</span>
</pre></div>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>A parallel-safe distributed multiset implementation that scales in terms of
nodes, processors per node (PPN), and workload; The more PPN, the more segments
we allocate to increase raw parallelism, and the larger the workload the better
locality (see <a class="reference internal" href="#DistributedBag.distributedBagInitialBlockSize" title="DistributedBag.distributedBagInitialBlockSize"><code class="xref chpl chpl-const docutils literal"><span class="pre">distributedBagInitialBlockSize</span></code></a>). This data structure is unordered
and employs its own workstealing algorithm to balance work across nodes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The documentation for the Collection modules are being incrementally revised and improved.</p>
</div>
</div>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>To use <a class="reference internal" href="#DistributedBag.DistBag" title="DistributedBag.DistBag"><code class="xref chpl chpl-record docutils literal"><span class="pre">DistBag</span></code></a>, the constructor must be invoked explicitly to
properly initialize the structure. Using the default state without initializing
will result in a halt.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">bag</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DistBag</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="nx">targetLocales</span><span class="o">=</span><span class="nx">ourTargetLocales</span><span class="p">);</span>
</pre></div>
</div>
<p>While the bag is safe to use in a distributed manner, each node always operates on it&#8217;s privatized
instance. This means that it is easy to add data in bulk, expecting it to be distributed, when in
reality it is not; if another node needs data, it will steal work on-demand. This may not always be
desired, and likely will more memory consumption on a single node. We offer a way for the user to
invoke a more static load balancing approach, called <code class="xref chpl chpl-proc docutils literal"><span class="pre">balance</span></code>, which will redistributed work.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">bag</span><span class="p">.</span><span class="nx">addBulk</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="nx">N</span><span class="p">);</span>
<span class="nx">bag</span><span class="p">.</span><span class="nx">balance</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="planned-improvements">
<h2>Planned Improvements<a class="headerlink" href="#planned-improvements" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>Dynamic work-stealing will require an overhaul to use a helper algorithm to keep down
the number of tasks spawned. Currently user tasks will wait on the current work-stealer
task, which will spawn is own helper tasks which act as shepards, which then spawns more
in a fork-join fashion. This leads to an excessive amount of tasks being spawned at once.
To make matters worse, the waiting tasks don&#8217;t even get any elements, nor does the work
stealing task, which opens up the possibility of live-lock where nodes steal work back
and forth before either can process it.</li>
<li>Static work-stealing (A.K.A <code class="xref chpl chpl-proc docutils literal"><span class="pre">balance</span></code>) requires a rework that performs a more distributed
and fast way of distributing memory, as currently &#8216;excess&#8217; elements are shifted to a single
node to be redistributed in the next pass. On the note, we need to collapse the pass for moving
excess elements into a single pass, hopefully with a zero-copy overhead.</li>
</ol>
<dl class="data">
<dt id="DistributedBag.distributedBagInitialBlockSize">
<em class="property">config const </em><code class="descname">distributedBagInitialBlockSize</code> = 1024<a class="headerlink" href="#DistributedBag.distributedBagInitialBlockSize" title="Permalink to this definition">¶</a></dt>
<dd><p>The initial amount of elements in an unroll block. Each successive unroll block
is double the size of it&#8217;s predecessor, allowing for better locality for when
there are larger numbers of elements. The better the locality, the better raw
performance and easier it is to redistribute work.</p>
</dd></dl>

<dl class="data">
<dt id="DistributedBag.distributedBagWorkStealingRatio">
<em class="property">config const </em><code class="descname">distributedBagWorkStealingRatio</code> = 0.25<a class="headerlink" href="#DistributedBag.distributedBagWorkStealingRatio" title="Permalink to this definition">¶</a></dt>
<dd><p>To prevent stealing too many elements (horizontally) from another node&#8217;s segment
(hence creating an artifical load imbalance), if the other node&#8217;s segment has
less than a certain threshold (see <a class="reference internal" href="#DistributedBag.distributedBagWorkStealingMemCap" title="DistributedBag.distributedBagWorkStealingMemCap"><code class="xref chpl chpl-const docutils literal"><span class="pre">distributedBagWorkStealingMemCap</span></code></a>) but above
another threshold (see <a class="reference internal" href="#DistributedBag.distributedBagWorkStealingMinElems" title="DistributedBag.distributedBagWorkStealingMinElems"><code class="xref chpl chpl-const docutils literal"><span class="pre">distributedBagWorkStealingMinElems</span></code></a>), we steal a percentage of their
elements, leaving them with majority of their elements. This way, the amount the
other segment loses is proportional to how much it owns, ensuring a balance.</p>
</dd></dl>

<dl class="data">
<dt id="DistributedBag.distributedBagWorkStealingMemCap">
<em class="property">config const </em><code class="descname">distributedBagWorkStealingMemCap</code>: real = 1.0<a class="headerlink" href="#DistributedBag.distributedBagWorkStealingMemCap" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum amount of work to steal from a horizontal node&#8217;s segment. This
should be set to a value, in megabytes, that determines the maximum amount of
data that should be sent in bulk at once. The maximum number of elements is
determined by: (<a class="reference internal" href="#DistributedBag.distributedBagWorkStealingMemCap" title="DistributedBag.distributedBagWorkStealingMemCap"><code class="xref chpl chpl-const docutils literal"><span class="pre">distributedBagWorkStealingMemCap</span></code></a> * 1024 * 1024) / sizeof(<code class="xref chpl chpl-type docutils literal"><span class="pre">eltType</span></code>).
For example, if we are storing 8-byte integers and have a 1MB limit, we would
have a maximum of 125,000 elements stolen at once.</p>
</dd></dl>

<dl class="data">
<dt id="DistributedBag.distributedBagWorkStealingMinElems">
<em class="property">config const </em><code class="descname">distributedBagWorkStealingMinElems</code> = 1<a class="headerlink" href="#DistributedBag.distributedBagWorkStealingMinElems" title="Permalink to this definition">¶</a></dt>
<dd><p>The minimum number of elements a horizontal segment must have to become eligible
to be stolen from. This may be useful if some segments produce less elements than
others and should not be stolen from.</p>
</dd></dl>

<dl class="data">
<dt id="DistributedBag.distributedBagMaxBlockSize">
<em class="property">config const </em><code class="descname">distributedBagMaxBlockSize</code> = 1024*1024<a class="headerlink" href="#DistributedBag.distributedBagMaxBlockSize" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum amount of elements in an unroll block. This is crucial to ensure memory
usage does not rapidly grow out of control.</p>
</dd></dl>

<dl class="record">
<dt id="DistributedBag.DistBag">
<em class="property">record </em><code class="descname">DistBag</code><a class="headerlink" href="#DistributedBag.DistBag" title="Permalink to this definition">¶</a></dt>
<dd><p>A parallel-safe distributed multiset implementation that scales in terms of
nodes, processors per node (PPN), and workload; The more PPN, the more segments
we allocate to increase raw parallelism, and the larger the workload the better
locality (see <a class="reference internal" href="#DistributedBag.distributedBagInitialBlockSize" title="DistributedBag.distributedBagInitialBlockSize"><code class="xref chpl chpl-const docutils literal"><span class="pre">distributedBagInitialBlockSize</span></code></a>). This data structure is unordered and employs
its own work-stealing algorithm, and provides a means to obtain a privatized instance of
the data structure for maximized performance.</p>
<dl class="attribute">
<dt id="DistributedBag.DistBag.eltType">
<em class="property">type </em><code class="descname">eltType</code><a class="headerlink" href="#DistributedBag.DistBag.eltType" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="DistributedBag.DistBag._impl">
<em class="property">var </em><code class="descname">_impl</code>: DistributedBagImpl(eltType)<a class="headerlink" href="#DistributedBag.DistBag._impl" title="Permalink to this definition">¶</a></dt>
<dd><p>The implementation of the Bag is forwarded. See <a class="reference internal" href="#DistributedBag.DistributedBagImpl" title="DistributedBag.DistributedBagImpl"><code class="xref chpl chpl-class docutils literal"><span class="pre">DistributedBagImpl</span></code></a> for
documentation.</p>
</dd></dl>

<dl class="method">
<dt id="DistributedBag.DistBag.forwarding_expr1__value">
<em class="property">proc </em><code class="descname">forwarding_expr1__value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DistributedBag.DistBag.forwarding_expr1__value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="DistributedBag.DistributedBagImpl">
<em class="property">class </em><code class="descname">DistributedBagImpl</code>: CollectionImpl<a class="headerlink" href="#DistributedBag.DistributedBagImpl" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="DistributedBag.DistributedBagImpl.targetLocales">
<em class="property">var </em><code class="descname">targetLocales</code>: [targetLocDom] locale<a class="headerlink" href="#DistributedBag.DistributedBagImpl.targetLocales" title="Permalink to this definition">¶</a></dt>
<dd><p>The locales to allocate bags for and load balance across.</p>
</dd></dl>

<dl class="method">
<dt id="DistributedBag.DistributedBagImpl.DistributedBagImpl">
<em class="property">proc </em><code class="descname">DistributedBagImpl</code><span class="sig-paren">(</span><em>type eltType</em>, <em>targetLocales: [?targetLocDom] locale = Locales</em><span class="sig-paren">)</span><a class="headerlink" href="#DistributedBag.DistributedBagImpl.DistributedBagImpl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="DistributedBag.DistributedBagImpl.add">
<em class="property">proc </em><code class="descname">add</code><span class="sig-paren">(</span><em>elt: eltType</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#DistributedBag.DistributedBagImpl.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an element to this node&#8217;s bag. The ordering is not guaranteed to be
preserved.</p>
</dd></dl>

<dl class="method">
<dt id="DistributedBag.DistributedBagImpl.remove">
<em class="property">proc </em><code class="descname">remove</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: (bool, eltType)<a class="headerlink" href="#DistributedBag.DistributedBagImpl.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove an element from this node&#8217;s bag. The order in which elements are removed
are not guaranteed to be the same order it has been inserted. If this node&#8217;s
bag is empty, it will attempt to steal elements from bags of other nodes.</p>
</dd></dl>

<dl class="method">
<dt id="DistributedBag.DistributedBagImpl.getSize">
<em class="property">proc </em><code class="descname">getSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: int<a class="headerlink" href="#DistributedBag.DistributedBagImpl.getSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the number of elements held in all bags across all nodes. This method
is best-effort and can be non-deterministic for concurrent updates across nodes,
and may miss elements or even count duplicates resulting from any concurrent
insertion or removal operations.</p>
</dd></dl>

<dl class="method">
<dt id="DistributedBag.DistributedBagImpl.contains">
<em class="property">proc </em><code class="descname">contains</code><span class="sig-paren">(</span><em>elt: eltType</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#DistributedBag.DistributedBagImpl.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a lookup to determine if the requested element exists in this bag.
This method is best-effort and can be non-deterministic for concurrent
updates across nodes, and may miss elements resulting from any concurrent
insertion or removal operations.</p>
</dd></dl>

<dl class="method">
<dt id="DistributedBag.DistributedBagImpl.clear">
<em class="property">proc </em><code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DistributedBag.DistributedBagImpl.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear all bags across all nodes in a best-effort approach. Elements added or
moved around from concurrent additions or removals may be missed while clearing.</p>
</dd></dl>

<dl class="method">
<dt id="DistributedBag.DistributedBagImpl.balance">
<em class="property">proc </em><code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DistributedBag.DistributedBagImpl.balance" title="Permalink to this definition">¶</a></dt>
<dd><p>Triggers a more static approach to load balancing, fairly redistributing all
elements fairly for bags across nodes. The result will result in all segments
having roughly the same amount of elements.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is very heavy-weight in that it should not be called too
often. Dynamic work stealing handles cases where there is a relatively fair
distribution across majority of nodes, but this should be called when you have
a severe imbalance, or when you have a smaller number of elements to balance.
Furthermore, while this operation is parallel-safe, it should be called from at
most one task.</p>
</div>
</dd></dl>

<dl class="itermethod">
<dt id="DistributedBag.DistributedBagImpl.these">
<em class="property">iter </em><code class="descname">these</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: eltType<a class="headerlink" href="#DistributedBag.DistributedBagImpl.these" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over each bag in each node. To avoid holding onto locks, we take
a snapshot approach, increasing memory consumption but also increasing parallelism.
This allows other concurrent, even mutating, operations while iterating,
but opens the possibility to iterating over duplicates or missing elements
from concurrent operations.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>zip</cite> iteration is not yet supported with rectangular data structures.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Iteration takes a snapshot approach, and as such can easily result in a
Out-Of-Memory issue. If the data structure is large, the user is doubly advised to use
parallel iteration, for both performance and memory benefit.</p>
</div>
</dd></dl>

<dl class="itermethod">
<dt>
<em class="property">iter </em><code class="descname">these</code><span class="sig-paren">(</span><em>param tag: iterKind</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="itermethod">
<dt>
<em class="property">iter </em><code class="descname">these</code><span class="sig-paren">(</span><em>param tag: iterKind</em>, <em>followThis</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="DistributedDeque.html" class="btn btn-neutral float-right" title="DistributedDeque" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Collection.html" class="btn btn-neutral" title="Collection" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, .

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 



</body>
</html>