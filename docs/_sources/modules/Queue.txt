.. default-domain:: chpl

.. module:: Queue

Queue
=====
**Usage**

.. code-block:: chapel

   use Queue;

.. class:: Queue

   .. attribute:: type eltType

   .. method:: proc enqueue(elt: eltType)

   .. method:: proc enqueue(elt: eltType ...?nElts)

   .. method:: proc enqueue(queue: Queue(eltType))

   .. method:: proc enqueue(iterObj)

   .. method:: proc dequeue(): (bool, eltType)

   .. method:: proc dequeue(nElems): (int, AppendExpr.Call08)

.. class:: QueueFactory

   .. method:: proc makeDistributedBoundedFIFO(type eltType, maxElems: uint = 0, targetLocales: [] locale = Locales): Queue(eltType)

      
      (WIP - In Planning)
      
      Creates a bounded strict First-In-First-Out Queue. The queue utilizes a distributed
      array and provides wait-free dequeue operations. The queue is dervied from the
      'FFQ: A Fast Single-Producer/Multiple-Consumer Concurrent FIFO Queue' seen here:
      http://se.inf.tu-dresden.de/pubs/papers/ffq2017.pdf
      
      To allow safe concurrent enqueuers, an extension is required that combines the
      high performance of the CC-Synch algorithm to create a derived variant of H-Synch
      I call the 'FCHLock', or the 'Flat Combining Hierarichal Lock'. An extremely helpful
      slide can be seen here:
      https://opencourses.uoc.gr/courses/pluginfile.php/17173/mod_resource/content/0/HY586-Section3.pdf
      
      :type eltType: Element type
      
      :arg maxElems: Maximum number of elements in the queue; halts if value is 0.
      :type maxElems: uint
      
      :arg targetLocales: Locales to distribute across.
      :type targetLocales: [] locales
      
      :rtype: DistributedBoundedFIFO(eltType)
      

   .. method:: proc makeBoundedFIFO(type eltType, maxElems: uint = 0): Queue(eltType)

   .. method:: proc makeDistributedUnboundedFIFO(type eltType, targetLocales: [] locale = Locales): Queue(eltType)

      
      Creates an unbounded strict First-In-First-Out Queue. In this queue, each locale is
      given their own queue, which uses a wait-free round robin algorithm to fairly
      distribute computation, memory, and bandwidth and offers scalable performance.
      The queue also allows the user to use their own custom backbone queues but defaults
      to Michael Scott's two-locked synchronized queue, seen here:
      https://www.research.ibm.com/people/m/michael/podc-1996.pdf
      
      :type eltType: Element type
      
      :arg targetLocales: Locales to distribute across.
      :type targetLocales: [] locales
      
      :rtype: DistributedUnboundedFIFO(eltType)
      

   .. method:: proc makeUnboundedFIFO(type eltType): Queue(eltType)

   .. method:: proc makeDistributedWorkQueue(type eltType, targetLocales: [] locale = Locales): Queue(eltType)

      
      (WIP - Implementing)
      
      

   .. method:: proc makeWorkQueue(type eltType): Queue(eltType)

