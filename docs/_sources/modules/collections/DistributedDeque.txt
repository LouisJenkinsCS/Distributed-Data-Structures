.. default-domain:: chpl

.. module:: DistributedDeque
   :synopsis: A parallel-safe scalable distributed deque. A deque is a double-ended queue that supports

DistributedDeque
================
**Usage**

.. code-block:: chapel

   use DistributedDeque;


A parallel-safe scalable distributed deque. A deque is a double-ended queue that supports
insertion and removal from both ends of the queue, effectively supporting both
FIFO, LIFO, and a Total ordering, where the order in which you add them will be
the exact order you remove them in; for emphasis, a Deque can be used as a Queue,
a Stack, and a List respectively.

First, the :record:`DistDeque` must be initialized before use by calling its constructor.

.. code-block:: chapel
  
  var deque = new DistDeque(int, cap=maxElem, targetLocales=ourLocales);

The deque can be used as a queue by using the :proc:`enqueue` and :proc:`dequeue` convenience
methods or inserting from one end to remove from another...

.. code-block:: chapel

  deque.enqueue(1);
  var (hasElem, elem) = deque.dequeue();

The deque can be used as a stack by using the :proc:`push` and :proc:`pop` convenience methods,
or insertion and removing from the same ends...

.. code-block:: chapel

  deque.push(1);
  var (hasElem, elem) = deque.pop();

The deque can be used as a list by using the :proc:`pushBack`, :proc:`pushFront`, :proc:`popBack`,
and :proc:`popFront` methods. While the deque is not indexable, the ability to `append` or `prepend`
is powerful enough to allow a total ordering, allowing the user to define the order by letting them
insert and remove at whichever ends they so choose.

.. code-block:: chapel
  
  var deque = new DistDeque(int);
  forall i in 1 .. N {
    if i % 2 == 0 then deque.pushFront(i);
    else deque.pushBack(i);
  }

The deque supports both serial and parallel iteration, and a means to iterate in a particular order
(currently only FIFO and LIFO) using the `Ordering` enumerator.

.. code-block:: chapel

  for elt in deque.these(Ordering.FIFO) {
    // ...
  }

  for elt in deque.these(Ordering.LIFO) {
    // ...
  }

The deque can also be used in a reduction, although currently reduction only used parallel-iteration, hence
reduction will be performed in an unordered fashion. In the future, a specific function may be created to
allow reduction in a certain ordering...

.. code-block:: chapel

  deque.addBulk(1..100);
  var result = + reduce deque;
  

.. data:: config param distributedDequeBlockSize = 8

   
   Size of each unroll block for each local deque node.
   

.. enum:: enum Ordering { NONE, FIFO, LIFO }

   
   The ordering used for serial iteration. NONE, the default, is the most performant
   and is algorithmically similar to parallel iteration.
   


.. record:: DistDeque

   
   A parallel-safe scalable distributed double-ended queue that supports both
   insertion and removal from either end of the queue. Can be used as a Queue,
   Stack, or even a List.
   


   .. attribute:: type eltType

   .. method:: proc DistDeque(type eltType, cap = -1, targetLocales = Locales)

   .. method:: proc _value

   .. method:: proc forwarding_expr2__value()

