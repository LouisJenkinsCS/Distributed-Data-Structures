.. default-domain:: chpl

.. module:: DistributedBag

DistributedBag
==============
**Usage**

.. code-block:: chapel

   use DistributedBag;

.. data:: config param distributedBagInitialBlockSize = 1024

   
   The initial amount of elements in an unroll block. Each successive unroll block
   is double the size of it's predecessor, allowing for better locality for when
   there are larger numbers of elements. The better the locality, the better raw
   performance and easier it is to redistribute work.

.. data:: config param distributedBagWorkStealingRatio = 0.25

   
   To prevent stealing too many elements (horizontally) from another node's segment
   (hence creating an artifical load imbalance), if the other node's segment has
   less than a certain threshold (see `distributedBagWorkStealingMemCap`) but above
   another threshold (see `distributedBagWorkStealingMinElems`), we steal a percentage of their
   elements, leaving them with majority of their elements. This way, the amount the
   other segment loses is proportional to how much it owns, ensuring a balance.

.. data:: config param distributedBagWorkStealingMemCap: real = 1.0

   
   The maximum amount of work to steal from a horizontal node's segment. This
   should be set to a value, in megabytes, that determines the maximum amount of
   data that should be sent in bulk at once. The maximum number of elements is
   determined by: (distributedBagWorkStealingMemCap * 1024 * 1024) / sizeof(eltType).
   For example, if we are storing 8-byte integers and have a 1MB limit, we would
   have a maximum of 125,000 elements stolen at once.

.. data:: config param distributedBagWorkStealingMinElems = 1

   
   The minimum number of elements a horizontal segment must have to become eligible
   to be stolen from. This may be useful if some segments produce less elements than
   others and should not be stolen from.

.. class:: DistributedBag : Collection

   
   A parallel-safe distributed multiset implementation that scales in terms of
   nodes, processors per node (PPN), and workload; The more PPN, the more segments
   we allocate to increase raw parallelism, and the larger the workload the better
   locality (see `distributedBagInitialBlockSize`). This data structure is unordered and employs
   its own work-stealing algorithm, and provides a means to obtain a privatized instance of
   the data structure for maximized performance.


   .. attribute:: var targetLocales: [targetLocDom] locale

      
      The locales to allocate bags for and load balance across.
      

   .. method:: proc DistributedBag(type eltType, targetLocales: [?targetLocDom] locale = Locales)

   .. method:: proc getPrivatizedInstance()

      
      Obtains a privatized version of this instance. The privatized version is a
      cloned instance that is allocated on this node, which is useful for eliding
      communications generated from accessing instance fields. Using another node's
      instance will significantly penalize performance by bounding overall throughput
      on the communication between the two nodes.
      

   .. method:: proc add(elt: eltType): bool

      
      Insert an element to this node's bag. The ordering is not guaranteed to be
      preserved.
      

   .. method:: proc remove(): (bool, eltType)

      
      Remove an element from this node's bag. The order in which elements are removed
      are not guaranteed to be the same order it has been inserted. If this node's
      bag is empty, it will attempt to steal elements from bags of other nodes.
      

   .. method:: proc getSize(): int

      
      Obtain the number of elements held in all bags across all nodes. This method
      is best-effort and can be non-deterministic for concurrent updates across nodes,
      and may miss elements or even count duplicates resulting from any concurrent
      insertion or removal operations.
      

   .. method:: proc contains(elt: eltType): bool

      
      Performs a lookup to determine if the requested element exists in this bag.
      This method is best-effort and can be non-deterministic for concurrent
      updates across nodes, and may miss elements resulting from any concurrent
      insertion or removal operations.
      

   .. method:: proc clear()

      
      Clear all bags across all nodes in a best-effort approach. Elements added or
      moved around from concurrent additions or removals may be missed while clearing.
      

   .. method:: proc balance()

      
      Triggers a more static approach to load balancing, fairly redistributing all
      elements fairly for bags across nodes. The result will result in all segments
      having roughly the same amount of elements.
      
      **Note:** This method is very heavy-weight in that it should not be called too
      often. Dynamic work stealing handles cases where there is a relatively fair
      distribution across majority of nodes, but this should be called when you have
      a severe imbalance, or when you have a smaller number of elements to balance.
      Furthermore, while this operation is parallel-safe, it should be called in a
      sequential context.
      

   .. itermethod:: iter these(): eltType

      
      Iterate over each bag in each node. To avoid holding onto locks, we take
      a snapshot approach, increasing memory consumption but also increasing parallelism.
      This allows other concurrent, even mutating, operations while iterating,
      but opens the possibility to iterating over duplicates or missing elements
      from concurrent operations.
      
      **Warning:** Breaking from an iterator will leak the snapshot due to issue #6912.
      It will however leave all Bags in a safe state.
      

   .. itermethod:: iter these(param tag: iterKind)

   .. itermethod:: iter these(param tag: iterKind, followThis)

