.. default-domain:: chpl

.. module:: DistributedBag

DistributedBag
==============
**Usage**

.. code-block:: chapel

   use DistributedBag;

.. data:: config param INITIAL_BLOCK_SIZE = 1024

   
   The initial amount of elements in an unroll block. Each successive unroll block
   is double the size of it's predecessor.

.. data:: config param WORK_STEALING_RATIO = 0.25

   
   To prevent stealing too many elements (horizontally) from another node's segment
   (hence creating an artifical load imbalance), if the other node's segment has
   less than a certain threshold (see `WORK_STEALING_MAX_MEMORY_MB`) but above
   another threshold (see `WORK_STEALING_MINIMUM`), we steal a percentage of their
   elements, leaving them with majority of their elements. This way, the amount the
   other segment loses is proportional to how much it owns, ensuring a balance.

.. data:: config param WORK_STEALING_MAX_MEMORY_MB: real = 1.0

   
   The maximum amount of work to steal from a horizontal node's segment. This
   should be set to a value, in megabytes, that determines the maximum amount of
   data that should be sent in bulk at once. The maximum number of elements is
   determined by: (WORK_STEALING_MAX_MEMORY_MB * 1024 * 1024) / sizeof(eltType).
   For example, if we are storing 8-byte integers and have a 1MB limit, we would
   have a maximum of 125,000 elements stolen at once.

.. data:: config param BAG_NO_FREEZE = false

   
   Determines whether or not we check if we are 'frozen'. These checks cause a
   significant decline in performance, of about 33%. If the utility is not needed,
   as it is more useful when reads are performed more often than writes, it may
   be disabled for a raw performance boost. If the user attempts to freeze the
   bag with this set to true, it merely returns false; all other checks are elided.

.. data:: config param WORK_STEALING_MINIMUM = 1

   
   The minimum number of elements a horizontal segment must have to become eligible
   to be stolen from. This may be useful if some segments produce less elements than
   others and should not be stolen from.

.. class:: DistributedBag : Collection

   
   A parallel-safe distributed multiset implementation that scales in terms of
   both nodes and processors per node. This data structure is unordered and employs
   its own work-stealing algorithm, and provides a means to obtain a privatized instance of
   the data structure for maximized performance. This is an ideal backbone for a
   means to distribute work across nodes.


   .. attribute:: var targetLocales: [targetLocDom] locale

      
      The locales to allocate bags for and load balance across.
      

   .. method:: proc DistributedBag(type eltType, targetLocales: [?targetLocDom] locale = Locales)

   .. method:: proc getPrivatizedInstance()

      
      Obtains a privatized version of this instance. The privatized version is a
      cloned instance that is allocated on this node, which is useful for eliding
      communications generated from accessing instance fields. Using another node's
      instance will significantly penalize performance by bounding overall throughput
      on the communication between the two nodes.
      

   .. method:: proc add(elt: eltType): bool

      
      Insert an element to this node's bag. The ordering is not guaranteed to be
      preserved. If this instance is privatized, it is an entirely local operation.
      

   .. method:: proc remove(): (bool, eltType)

      
      Remove an element from this node's bag. The order in which elements are removed
      are not guaranteed to be the same order it has been inserted. If this node's
      bag is empty, it will attempt to steal elements from bags of other nodes.
      

   .. method:: proc size(): int

      
      Obtain the number of elements held in all bags across all nodes. This method
      is best-effort if the bags are unfrozen, and can be non-deterministic for
      concurrent updates across nodes, and may miss elements or even count
      duplicates resulting from any concurrent insertion or removal operations.
      

   .. method:: proc contains(elt: eltType): bool

      
      Performs a lookup to determine if the requested element exists in this bag.
      This method is best-effort if the bags are unfrozen, and can be
      non-deterministic for concurrent updates across nodes, and may miss elements
      resulting from any concurrent insertion or removal operations.
      

   .. method:: proc freeze()

      
      Freeze our state, becoming immutable; we wait for any ongoing concurrent
      operations to allow them to finish.
      

   .. method:: proc unfreeze(): bool

      
      Unfreezes our state, allowing mutating operations; we wait on any ongoing
      concurrent operations to allow them to finish.
      

   .. method:: proc canFreeze(): bool

   .. method:: proc isFrozen(): bool

      
      If we are currently frozen. If we are in the middle of a state transition, we
      wait until it has completed.
      

   .. method:: proc clear()

      
      Clear all bags across all nodes in a best-effort approach. Elements added or
      moved around from concurrent additions or removals (including work stealing)
      may be missed while clearing.
      

   .. method:: proc balance()

      
      Triggers a more static approach to load balancing; note that this operation
      is parallel-safe but is performed in parallel across all `targetLocales` and
      should only be called at a point of synchronization.
      

   .. itermethod:: iter these(): eltType

      
      Iterate over each bag in each node. If the bag is frozen, we elide the need
      to acquire any locks and iterate directly over the bag. If the bag is not
      frozen, we must acquire not only the needed locks, but also take a snapshot
      approach, increasing memory consumption.
      

   .. itermethod:: iter these(param tag: iterKind)

   .. itermethod:: iter these(param tag: iterKind, followThis)

