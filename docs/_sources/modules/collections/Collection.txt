.. default-domain:: chpl

.. module:: Collection

Collection
==========
**Usage**

.. code-block:: chapel

   use Collection;

.. class:: Collection

   
   A 'Collection' is a data structure, a container for elements that provide support
   for insert, lookup, remove, and iteration operations.


   .. attribute:: type eltType

      
      The type of element that this Collection holds.
      

   .. method:: proc add(elt: eltType): bool

      
      Adds an element to this data structure.
      

   .. method:: proc remove(): (bool, eltType)

      
      Removes an arbitrary element from this data structure.
      
      **BUG:** Compiler will segfault if the returned value is not captured at callsite.
      Issue: #6542
      
      **FIX:** Ensure that you always capture the return value...
      
      ::
      
        var capturedRetval = c.remove()
      
      **BUG:** Loop Invariant Code Motion causes undefined behavior if assigned to a
      variable declared outside of loop. Issue: #7003
      
      **FIX:** Use the `--no-loop-invariant-code-motion` to disable LICM.
      Otherwise, just make sure you always capture the return value inside of a loop
      in a variable not declared outside of loop...
      
      ::
      
        for i in 1 .. N {
          var retval = c.remove();
        }
      
      

   .. method:: proc contains(elt: eltType): bool

      
      Determine whether an element exists in this collection.
      

   .. method:: proc clear()

      
      Clears all elements in this collection.
      

   .. method:: proc isEmpty(): bool

      
      Check if this data structure is empty.
      

   .. method:: proc length: int

      
      Syntactic sugar for `getSize`.
      

   .. method:: proc size: int

      
      Syntactic sugar for `getSize`.
      

   .. method:: proc getSize(): int

      
      Obtain the number of elements contained in this collection.
      

   .. itermethod:: iter these(): eltType

      
      Iterate over all elements in the data structure.
      
      **BUG:** Compiler does not currently allow overloading standalone or leader/follower
      iterators, and as such only serial iterators may be used with the base type. See
      issue #6998
      
      **BUG:** Resources are not properly cleaned up when the user breaks or returns
      from a serial iterator, and so this *must* be avoided at all cost. See issue #6912
      

.. function:: proc +=(ref c: Collection(?eltType), elt: eltType)

   
   Syntactic sugar for 'add'.
   
   **BUG:** Compiler produces a warning that `c` should be a `ref`, when it is not needed
   because it is a class and can be used by value. Need a pragma to disable this?
   As such, this cannot be used where `ref` intents cannot be used, such as ``forall``
   and ``coforall`` loops.

